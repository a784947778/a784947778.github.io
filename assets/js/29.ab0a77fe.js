(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{305:function(n,t,a){"use strict";a.r(t);var e=a(13),s=Object(e.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"多线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[n._v("#")]),n._v(" 多线程")]),n._v(" "),t("p",[n._v("总结：\n同一个类或者子父类的两个方法同时被 synchronized 修饰，一个线程同时调用这两个方法，会有锁重入现象，不会影响正常的执行结果。多个线程访问 synchronized 修饰的方法或代码块儿，必须保证锁对象时不可变的\nThreadLocal的用法\nvolatile 关键字，只能保证数据的在多线程之前的可见性，不能保证数据的原子性。（Atomic***类能保证无论代码的过程是什么或者打印的结果是什么，最终主内存的结果都能得到想要的），注：volatile有一个很重要的特点，防止指令重排序\nwait 和 notify 方法实现线程间的通信，都是Object类提供的方法，不能做到实时通知，CountDownLatch能解决实时通知的问题")]),n._v(" "),t("p",[n._v("问题：\n类成员变量和普通成员变量在内存中和线程中的区别\nConcurrentModificationException异常\n什么是阻塞队列，什么是非阻塞队列\n什么是可重入锁？\n多线程中volatile的理解和static的区别？\n不用分布式锁怎么应对1000个以上并发，三种分布式锁方案？\n宕机问题，代码抛异常问题，多个线程执行代码时间差问题怎？")]),n._v(" "),t("p",[n._v('{\n问题：Unsafe 有一public 方法：getUnsafe() , 返回值是Unsafe的实例。如果直接调用会抛： Exception in thread "main" java.lang.SecurityException: Unsafe。 有这样一段说明： Although the class and all methods are public, use of this class is limited because only trusted code can obtain instances of it.  所以只有java认为是安全的代码才可以获取Unsafe实例。\n解决：https://blog.csdn.net/hezuideda/article/details/45132229\n}')]),n._v(" "),t("p",[n._v("线程中用到的设计模式\n线程中用到的各种队列\n线程中用到的各种线程池\n线程中出现的假死状态\nUnsafe：\n1、初始化\n2、操作属性方法\n3、操作数组\n4、内存管理\n5、线程挂起和恢复\n6、内存屏障\n7、CAS机制")]),n._v(" "),t("p",[n._v("https://www.pdai.tech/md/java/collection/java-collection-Queue&Stack.html")]),n._v(" "),t("p",[n._v("https://mp.weixin.qq.com/s/jd2pxCHwzV9HK84-bzNpcQ 高并发")]),n._v(" "),t("h2",{attrs:{id:"线程池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池"}},[n._v("#")]),n._v(" 线程池")]),n._v(" "),t("p",[n._v("ThreadPoolExecutor")])])}),[],!1,null,null,null);t.default=s.exports}}]);